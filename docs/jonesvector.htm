<html>
<head>
<link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">
<script src="https://pages.nist.gov/nist-header-footer/js/jquery-1.9.0.min.js" type="text/javascript" defer="defer"></script>
<script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
  <meta name="generator" content=
  "HTML Tidy for Cygwin (vers 1st September 2004), see www.w3.org">
   <link rel="STYLESHEET" href="style.css" type="text/css">

  <title>SCATMECH: JonesVector</title>
<script language="JavaScript" id="_fed_an_js_tag" src="/js/federated-analytics.all.min.js?agency=NIST&subagency=pml&pua=UA-37115410-46&yt=true"></script>
</head>

<body><br>
  <a name="top" id="top"><!-- --></a>

  <table width="98%" border="0" cellpadding="0" cellspacing="0" align="center">
    <tr>
      <td>
        <p class="nav"><a href="index.htm">SCATMECH</a> &gt; <a href=
        "classes.htm">Classes and Functions</a> &gt;
        <a href="classes.htm#Pol">Polarization</a> &gt; JonesVector</p>

        <h1>class JonesVector</h1>

        <hr>

	<p>The class <b>JonesVector</b> represents a Jones vector in a
        Jones representation of polarization states. Arithmetic
        operations between Jones matrices and Jones vectors,
        various properties of a Jones vector, and transformation
        operations are defined.

        <p>SCATMECH assumes an exp(-<i>i</i><img src=
        "Images/omega.gif" alt="omega"><i>t</i>) time dependence in
        the Jones vector. Furthermore, it is assumed that the basis
        set for representing the Jones vector, {s,p,k}, is such
        that {s,p,k} form a right-handed triplet. With this
        convention, (1,<i>i</i>) and (-<i>i</i>,1) represent
        left-circularly polarized light, while (1,-<i>i</i>) or
        (<i>i</i>,1) represent right-circularly polarized
        light.</p>

	<h2>Include file:</h2>

          <pre>
#include "<a href="../code/mueller.h">mueller.h</a>"
</pre>
        <h2>Source code:</h2>

          <pre>
<a href="../code/jvector.cpp">jvector.cpp</a>
</pre>
        <h2>See also:</h2>

        <p><a href="index.htm">SCATMECH Home</a>, &nbsp;
        <a href="convent.htm">Conventions</a>, &nbsp; <a href=
        "muellermatrix.htm">MuellerMatrix</a>, &nbsp; <a href=
        "jonesmatrix.htm">JonesMatrix</a>, &nbsp; <a href=
        "stokesvector.htm">StokesVector</a></p>

        <p>
	<a name="RefBohren" id="RefBohren"></a><a href="http://dx.doi.org/10.1002/9783527618156">C.F. Bohren and D.R. Huffman, <i>Absorption and Scattering of Light by Small Particles</i>, (Wiley, New York, 1983).</a><br>
        <a name="RefHulst" id="RefHulst"></a><a href="https://books.google.com/books?hl=en&lr=&id=PlHfPMVAFRcC&oi=fnd&pg=PA1&ots=Gg_gMuimH7&sig=gqf0sZ1ELYIDmyxa0vLzXIPcLWs">H.C. van de Hulst, <i>Light Scattering by Small Particles</i>, (Dover, New York, 1981).</a><br>
        <a name="RefChipman" id="RefChipman"></a><a href="https://books.google.com/books/about/Handbook_of_Optics_Fundamentals_techniqu.html?id=ggc6AQAAIAAJ">R.A. Chipman, &quot;Polarimetry.&quot; in <i>Handbook of Optics</i>, (McGraw-Hill, New York, 1995).</a><br>


	<h2>Definition of public
        elements:</h2>

          <pre>
class JonesVector {
    public:
        <a href="#JonesVector()">JonesVector</a>();
        <a href="#JonesVector(constJonesVector)">JonesVector</a>(const JonesVector&amp; x);
        <a href="#JonesVector(constCOMPLEXconstCOMPLEX)">JonesVector</a>(const COMPLEX&amp; s,const COMPLEX&amp; p);
        explicit <a href="#JonesVector(constStokesVector)">JonesVector</a>(const StokesVector&amp; x);
        JonesVector&amp; <a href="#operator=(constJonesVector)">operator=</a>(const JonesVector&amp; x);
        JonesVector <a href="#operatort(constCOMPLEX)">operator*</a>(const COMPLEX&amp; x) const;
        friend JonesVector <a href="#operatort(constCOMPLEXconstJonesVector)">operator*</a>(const COMPLEX&amp; x,const JonesVector&amp; y);
        JonesVector <a href="#operatord(constCOMPLEX)">operator/</a>(const COMPLEX&amp; x) const;
        JonesVector&amp; <a href="#operatorte(constCOMPLEX)">operator*=</a>(const COMPLEX&amp; x);
        JonesVector&amp; <a href="#operatorde(constCOMPLEX)">operator/=</a>(const COMPLEX&amp; x);
        JonesVector <a href="#operatorp(constJonesVector)">operator+</a>(const JonesVector&amp; a) const;
        JonesVector <a href="#operatorm(constJonesVector)">operator-</a>(const JonesVector&amp; a) const;
        JonesVector <a href="#operatorpe(constJonesVector)">operator+=</a>(const JonesVector&amp; a);
        JonesVector <a href="#operatorme(constJonesVector)">operator-=</a>(const JonesVector&amp; a);
        JonesVector <a href="#operatorn()">operator-</a>() const;
        COMPLEX&amp; <a href="#operatorof(int)">operator[]</a>(int i);
        double <a href="#intensity()">intensity</a>() const;
        double <a href="#psi()">psi</a>() const;
        double <a href="#delta()">delta</a>() const;
        double <a href="#eta()">eta</a>() const;
        double <a href="#DOLP()">DOLP</a>() const;
        double <a href="#DOP()">DOP</a>() const;
        double <a href="#DOCP()">DOCP</a>() const;
        double <a href="#e()">e</a>() const;
        double <a href="#epsilon()">epsilon</a>() const;
        JonesVector <a href="#rotate(double)">rotate</a>(double angle) const;
        COMPLEX&amp; <a href="#S()">S</a>();
        COMPLEX&amp; <a href="#P()">P</a>();
};

ostream&amp; <a href="#operatorltlt">operator&lt;&lt;</a>(ostream&amp; os,JonesVector&amp; j);
istream&amp; <a href="#operatorgtgt">operator&gt;&gt;</a>(istream&amp; is,JonesVector&amp; j);
</pre>
        <hr>

        <h3><a name="JonesVector()" id= "JonesVector()">JonesVector()</a></h3>

        <blockquote><p>
          Constructor, which does not initialize the
          vector.
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name= "JonesVector(constJonesVector)" id="JonesVector(constJonesVector)">JonesVector(const
        JonesVector&amp; x)</a></h3>

        <blockquote><p>
          Copy constructor.
        <h4>Example:</h4>

          <pre>
JonesVector v1;
JonesVector v2(v1);
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="JonesVector(constCOMPLEXconstOMPLEX)" id="JonesVector(constCOMPLEXconstCOMPLEX)">
        JonesVector(const COMPLEX&amp; a,const COMPLEX&amp;
        b)</a></h3>

        <blockquote><p>
          Constructor that assigns values to the elements
          [<b>S()</b>=<b>a</b> and <b>P()</b>=<b>b</b>].
        <h4>Example:</h4>

          <pre>
JonesVector v(COMPLEX(1,0),0);
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name= "JonesVector(constStokesVector)" id= "JonesVector(constStokesVector)">explicit
        JonesVector(const StokesVector&amp; x)</a></h3>

        <blockquote><p>
          Explicit constructor that converts the polarized part of
          a <b>StokesVector</b> to a <b>JonesVector</b>. The first
          element of the <b>JonesVector</b> is left as real, with
          the relative phase taken up by the second element.
        <h4>Example:</h4>

          <pre>
StokesVector s1;
JonesVector j(s1);
StokesVector s2(j);  // s2 may not be equal to s1
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatore(constJonesVector)" id= "operator=(constJonesVector)">JonesVector&amp;
        operator=(const JonesVector&amp; x)</a></h3>

        <blockquote><p>
          Assignment operator.
        <h4>Example:</h4>

          <pre>
JonesVector a,b;
a=b;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>


	<h3><a name="operatort(constCOMPLEX)" id="operatort(constCOMPLEX)">
	    JonesVector operator*(const COMPLEX&amp; x) const</a><br>
        <a name="operatort(constCOMPLEX,constJonesVector)" id="operatort(constCOMPLEXconstJonesVector)">friend
        JonesVector operator*(const COMPLEX&amp; x,const JonesVector&amp; y)</a><br>
        <a name="operatord(constCOMPLEX)" id="operatord(constCOMPLEX)">
	  JonesVector operator/(const COMPLEX&amp; x) const</a><br>
        <a name="operatorte(constCOMPLEX)" id="operatort=(constCOMPLEX)">
	  JonesVector&amp; operator*=(const COMPLEX&amp; x)</a><br>
        <a name="operatorde(constCOMPLEX)" id="operatorde(constCOMPLEX)">
	  JonesVector&amp; operator/=(const COMPLEX&amp; x)</a></h3>

        <blockquote><p>
          Multiplication and division of a <b>JonesVector</b> by a
          scalar.
        <h4>Example:</h4>

          <pre>
JonesVector vector;
COMPLEX scalar;
vector = vector*scalar;
vector = scalar*vector; // Same thing.
vector *= scalar;       // Also same thing.
vector = vector/scalar;
vector /= scalar;       // Same thing.
vector = scalar/vector; // Not allowed.
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name= "operatorp(constJonesVector)" id= "operatorp(constJonesVector)">
	    JonesVector operator+(const JonesVector&amp; a) const</a><br>
        <a name="operatorm(constJonesVector)" id="operatorm(constJonesVector)">
	  JonesVector operator-(const JonesVector&amp; a) const</a><br>
        <a name="operatorpe(constJonesVector)" id="operatorpe(constJonesVector)">
	  JonesVector operator+=(const JonesVector&amp; a)</a><br>
        <a name="operatorme(constJonesVector)" id="operator(constJonesVector)">
	  JonesVector operator-=(const JonesVector&amp; a)</a></h3>

        <blockquote><p>
          Addition and subtraction of two <b>JonesVector</b>
          objects.
        <h4>Example:</h4>

          <pre>
JonesVector vector1,vector2;
vector1 = vector1+vector2;
vector1 += vector2;        // Same thing.
vector1 = vector1-vector2;
vector1 -= vector2;        // Same thing.
vector1 = vector2-vector1; // Inverse of previous.

</pre>

        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "operator-()" id="operatorn()">JonesVector operator-()
        const</a></h3>

        <blockquote><p>
          Negation of a <b>JonesVector</b>.
        <h4>Example:</h4>

          <pre>
JonesVector vector;
vector = -vector;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="operatorof(int)" id="operatorof(int)">
	    COMPLEX&amp; operator[](int i)</a></h3>

        <blockquote><p>
          Element referencing operation.
        <h4>Example:</h4>

          <pre>
JonesVector a;
a[0]=1;
a[1]=2;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "intensity()" id="intensity()">double intensity()
        const</a></h3>

        <blockquote><p>
          The intensity associated with the <b>JonesVector</b>.
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "Intensity = " &lt;&lt; a.intensity() &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "psi()" id="psi()">double psi() const</a></h3>

        <blockquote><p>
          The arctangent of the ratio of the two amplitudes. A
          value of zero indicates that the p-component of the field
          is zero.
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "psi = " &lt;&lt; a.psi()/PI*180; &lt;&lt; " deg" &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "delta()" id="delta()">double delta() const</a></h3>

        <blockquote><p>
          The phase between the two components of the
          <b>JonesVector</b>. A small positive phase indicates that
          the s-component is in advance of the p-component.
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "delta = " &lt;&lt; a.delta()/PI*180; &lt;&lt; " deg" &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="eta()" id="eta()">double eta() const</a></h3>

        <blockquote><p>
          The principal angle of the polarization. The angle is
          defined counterclockwise from s, looking into the beam.
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "eta = " &lt;&lt; a.eta()/PI*180; &lt;&lt; " deg" &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "DOLP()" id="DOLP()">double DOLP() const</a><br>
        <a name="DOP()" id="DOP()">double DOP() const</a><br>
        <a name="DOCP()" id="DOCP()">double DOCP() const</a></h3>

        <blockquote><p>
          The degrees of linear, circular, and total polarization.
          The degree of circular polarization is positive for
          left-circularly polarized light.
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "DOLP = " &lt;&lt; a.DOLP(); &lt;&lt; endl;
cout &lt;&lt; "DOCP = " &lt;&lt; a.DOCP(); &lt;&lt; endl;
cout &lt;&lt; "DOP = " &lt;&lt; a.DOP(); &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="e()" id="e()">double e() const</a></h3>

        <blockquote><p>
          The ellipticity of the field (ratio of minor axis to
          major axis).
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "ellipticity = " &lt;&lt; a.e(); &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>
	
	<h3><a name=
        "epsilon()" id="epsilon()">double epsilon()
        const</a></h3>

        <blockquote><p>
          The eccentricity [sqrt(1-e()^2)].
        <h4>Example:</h4>

          <pre>
JonesVector a;
cout &lt;&lt; "eccentricity = " &lt;&lt; a.epsilon(); &lt;&lt; endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name="rotate(double)" id="rotate(double)">
	    JonesVector rotate(const  double angle) const</a></h3>

        <blockquote><p>
          Function that returns a <b>JonesVector</b> rotated by an
          <b>angle</b>. The direction of rotation, for positive
          angle, is clockwise looking into the beam.
        <h4>Example:</h4>

          <pre>
JonesVector a,b;
b=a.rotate(45*PI/180);
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3><a name=
        "S()" id="S()">COMPLEX&amp; S()</a><br>
        <a name="P()" id="P()">COMPLEX&amp; P()</a></h3>

        <blockquote><p>
          References to the first (S) and second (P) element of the
          <b>JonesVector</b>.
        <h4>Example:</h4>

          <pre>
JonesVector a;
a.S()=1;
a.P()=2;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3>
        <a name="operatorltlt" id="operatorltlt">
        ostream&amp; operator&lt;&lt;(ostream&amp; os,JonesVector&amp; j)</a></h3>

        <blockquote><p>
          Operator that outputs a <b>JonesVector</b> to an output
          stream. The result contains two complex numbers, separated by a comma, and surrounded by parentheses, e.g., <tt>((1,2),(4,5))</tt>. 
	  The order of the elements is S and P.
	  <h4>Example</h4>
<pre>
JonesVector J;
cout >> "J = " <<  J << endl;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

	<h3>
        <a name="operatorgtgt" id="operatorgtgt">
	  istream&amp; operator&gt;&gt;(istream&amp; is,JonesVector&amp; j)</a></h3>

        <blockquote><p>
          Operator that inputs a <b>JonesVector</b> from an input
          stream. The stream should contain two complex numbers, separated by a comma, and surrounded by parentheses, e.g., <tt>((1,2),(4,5))</tt>. 
	  The order of the elements is S and P.
	  <h4>Example</h4>
<pre>
JonesVector J;
cin << J;
</pre>
        </blockquote>

        <p><a href="#top"><span class="totop">Top of Page</span></a></p>

<!-- START FOOTER -->
<hr>
<h2>For More Information</h2>

<p>
<a href="https://www.nist.gov/people/thomas-germer">SCATMECH Technical Information and Questions</a><br>
<a href="http://www.nist.gov/pml/div685/index.cfm" target="_top">Sensor Science Division Home Page</a><br>
<a href="mailto:fraser@nist.gov">Sensor Science Division Inquiries</a><br>
<a href="mailto:thomas.germer@nist.gov">Website Comments</a>

<p>
Current SCATMECH version: <a href="./download.htm">7.22 (April 2021)</a><br>
<br>

</td>
</tr>
</table>

</body>
</html>
